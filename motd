#!/usr/bin/python

r"""
A python Message of the Day script. Configure it through the parameters passed
to the get_motd function in the if __name__ == '__main__' section at the end of
the file, or, if you are so inclined, by importing this file and calling the
get_motd function yourself. 

In this default configuration, it prints a message similar to this:



I surely do hope that's a syntax error.
             -- Larry Wall in <199710011752.KAA21624@wall.org>

      /#\
     /###\
    /p^###\
   /##P^q##\
  /##(   )##\
 /###P   q#,^\ Linux TARDIS 4.10.9-1-ARCH 
/P^         ^q\ up for 1 hours, 40 minutes 



The Arch ASCII image is not hardcoded, but is rather loaded from ~/.motd_image
(this can be changed). More messages can also be added and the fortune message
at the top can be swapped out for something else or removed entirely. 
"""

import os
from collections import defaultdict
from time import sleep
import sys

from colorama import init, Fore, Style
from termcolor import colored
import sh


def get_motd(pre_message, image_path, messages, image_color=None):
    """
        Get the message of the day for the parameters given. This function is a
        generator that yields the message one line at a time.

        :param pre_message: The string to be shown above the image could be
        used, for example, for a fortune message.

        :param image_path: Path to a text file containing the ascii image to be
        shown on the left of the message.
        
        :param messages: The messages that will be printed next to the
        picture. It is a list of strings the will be printed next to the image,
        in the bottom left. So, for example, the list ['test1', 'test2'] would
        result in:
        *********
        *       *
        * image *
        *       * test1
        ********* test2

        :param image_color: The colorama Foreground color in which the image
        will be printed. If None is passed or the argument is left empty then
        no color is used.
    """

    if image_path is not None:
        with open(os.path.expanduser(image_path)) as image:
            image_lines = [line.rstrip() + ' ' for line in image.readlines()]
    else: 
        # list of empty strings as long as the messages list.
        image_lines = ['' for _ in messages] 

    yield pre_message

    yield image_color
    for i, image_line in enumerate(image_lines):
        try:
            # yield image line in color, and message without the image color
            yield ''.join([
                image_line, 
                Style.RESET_ALL, 
                messages[i - len(image_lines)], 
                image_color
            ])
        except IndexError:
            yield image_line

    yield Style.RESET_ALL

def simulate_typing(output, delay=.005):
    for c in output:
        sys.stdout.write(c)
        sys.stdout.flush()
        sleep(delay)
    

if __name__ == '__main__':

    fortune = sh.fortune('-s').rstrip()

    with open('/proc/uptime') as uptime_file:
        uptime_seconds = int(float(uptime_file.read().split()[0]))
        uptime_days    = uptime_seconds             // (24*3600)
        uptime_hours   = uptime_seconds % (24*3600) // 3600
        uptime_minutes = uptime_seconds % 3600      // 60
        
    uname = sh.uname('-snr').rstrip()

    # Find the line for the filesystem in the output of df -h, and split the columns
    fs_name         = 'sda2'
    df_data         = next(line for line in sh.df('-h') if fs_name in line).split()
    total_space     = df_data[1][:-1] # The [:-1] removes the unit (G/M/K, etc.)
    available_space = df_data[2][:-1]

    image_path  = '~/.motd_image'
    image_color = Fore.BLUE

    messages = [
        uname,
        f'{fs_name}: {available_space}/{total_space}GB available',
        f'up for {str(uptime_days) + " days, " if uptime_days != 0 else ""}'
            f'{uptime_hours} hours, {uptime_minutes} minutes'
    ]

    simulate_typing('\n'.join(get_motd(fortune, image_path, messages, image_color)))
